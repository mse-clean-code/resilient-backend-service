package clc.resilient.backend.service.data.services;

import clc.resilient.backend.service.data.objects.MovieList;
import clc.resilient.backend.service.data.objects.MovieRelation;
import clc.resilient.backend.service.data.repositories.MovieListRepository;
import clc.resilient.backend.service.data.repositories.MovieRelationRepository;
import clc.resilient.backend.service.list.validators.ListServiceValidation;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.groups.Default;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;

@Service
@Validated
public class MovieListQueryService {
    private final MovieListRepository movieListRepository;

    private final MovieRelationRepository movieRelationRepository;

    public MovieListQueryService(MovieListRepository movieListRepository, MovieRelationRepository movieRelationRepository) {
        this.movieListRepository = movieListRepository;
        this.movieRelationRepository = movieRelationRepository;
    }

    public List<MovieList> getAll() {
        return movieListRepository.findAll();
    }

    public MovieList getItem(Long id) throws NoSuchElementException {
        Optional<MovieList> optionalItem = movieListRepository.findById(id);
        return optionalItem.orElseThrow(NoSuchElementException::new);
    }

    @Transactional
    // Validate with specific group
    // https://reflectoring.io/bean-validation-with-spring-boot/
    // Required so hibernate does not call the @MovieListConstraint!
    @Validated({ListServiceValidation.class, Default.class})
    public MovieList addList(@Valid MovieList addList) {
        return movieListRepository.save(addList);
    }

    @Transactional
    public MovieList update(MovieList unknownItem) {
        if (unknownItem.getId() == null) {
            // Assuming the ID is generated by the database sequence/auto-increment.
            // Set other attributes and save to the database.
            Long id = (long) getAll().size();
            unknownItem.setId(id);
            unknownItem.setItems(new ArrayList<>());
            return movieListRepository.save(unknownItem);
        } else {
            Optional<MovieList> optionalItem = movieListRepository.findById(unknownItem.getId());
            if (optionalItem.isPresent()) {
                MovieList existingItem = optionalItem.get();
                // Update the existing item with the provided changes.
                // Assuming MovieList entity has setters similar to ListItem.
                // Update attributes and save changes to the database.
                if (unknownItem.getItems() != null) {
                    // Assuming items are movies within the list.
                    List<MovieRelation> pastItems = existingItem.getItems();
                    for (MovieRelation movie : unknownItem.getItems()) {
                        if (!pastItems.contains(movie)) {
                            movie = movieRelationRepository.saveAndFlush(movie);
                            pastItems.add(movie);
                        }
                    }
                    existingItem.setItems(pastItems);
                }
                if (unknownItem.getName() != null) {
                    existingItem.setName(unknownItem.getName());
                }
                if (unknownItem.getDescription() != null) {
                    existingItem.setDescription(unknownItem.getDescription());
                }
                existingItem.setPrivate(unknownItem.isPrivate());
                if (unknownItem.getBackdrop_path() != null) {
                    existingItem.setBackdrop_path(unknownItem.getBackdrop_path());
                }
                return movieListRepository.saveAndFlush(existingItem);
            } else {
                // Handle scenario where the item with the provided ID is not found.
                // You might want to throw an exception or handle it differently.
                return null;
            }
        }
    }

    @Transactional
    public void deleteList(@NotNull Long id) {
        movieListRepository.deleteById(id);
    }

    public List<MovieRelation> deleteMovie(MovieList toDeleteMovie) {
        Optional<MovieList> optionalItem = movieListRepository.findById(toDeleteMovie.getId());
        if (optionalItem.isPresent()) {
            MovieList item = optionalItem.get();
            List<MovieRelation> toDeleteMovies = toDeleteMovie.getItems();
            List<MovieRelation> movies = item.getItems();
            movies.removeAll(toDeleteMovies);
            item.setItems(movies);
            movieListRepository.saveAndFlush(item);
            return toDeleteMovie.getItems();
        } else {
            // Handle scenario where the item with the provided ID is not found.
            // You might want to throw an exception or handle it differently.
            return null;
        }
    }
}
